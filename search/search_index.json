{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"farcaster-py","text":"<p>farcaster-py is a modern Python SDK for the Farcaster Protocol.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U farcaster\n</code></pre> <p>or install with Poetry:</p> <pre><code>poetry add farcaster\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>This SDK leverages the Warpcast API. Warpcast is one of many Farcaster clients. As more APIs are created and hosted by different clients, these will be added to the SDK.</p> <p>To use the Warpcast API you need to have a Farcaster account. We will use the mnemonic or private key of the Farcaster custody account (not your main wallet) to connect to the API.</p> <p>First, save your Farcaster mnemonic or private key to a <code>.env</code> file. Now you can initialize the client, and automatically connect to the Farcaster API!</p> <pre><code>import os\nfrom farcaster import Warpcast\nfrom dotenv import load_dotenv\nload_dotenv()\nclient = Warpcast(mnemonic=os.environ.get(\"&lt;MNEMONIC_ENV_VAR&gt;\"))\nprint(client.get_healthcheck())\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Get a cast</p> <pre><code>response = client.get_cast(\"0x321712dc8eccc5d2be38e38c1ef0c8916c49949a80ffe20ec5752bb23ea4d86f\")\nprint(response.cast.author.username) # \"dwr\"\n</code></pre> <p>Publish a cast</p> <pre><code>response = client.post_cast(text=\"Hello world!\")\nprint(response.cast.hash) # \"0x....\"\n</code></pre> <p>Get a user by username</p> <pre><code>user = client.get_user_by_username(\"mason\")\nprint(user.username) # \"mason\"\n</code></pre> <p>Get a user's followers using a fid (farcaster ID)</p> <pre><code>response = client.get_followers(fid=50)\nprint(response.users) # [user1, user2, user3]\n</code></pre> <p>Stream recent casts</p> <pre><code>for cast in client.stream_casts():\nif cast:\nprint(cast.text) # \"Hello world!\"\n</code></pre> <p>Get users who recently joined Farcaster</p> <pre><code>response = client.get_recent_users()\nprint(response.users) # [user1, user2, user3]\n</code></pre> <p>Get your own user object</p> <pre><code>user = client.get_me()\nprint(user.username) # \"you\"\n</code></pre> <p>Recast a cast</p> <pre><code>response = client.recast(\"0x....\")\nprint(response.cast.hash) # \"0x....\"\n</code></pre> <p>and many, many more things.</p> <p>The full specification can be found on the References page.</p> <p>Still have questions? Chat with us here.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#farcaster.client.Warpcast","title":"<code>Warpcast</code>","text":"<p>The Warpcast class is a wrapper around the Farcaster API. It also provides a number of helpful methods and utilities for interacting with the protocol. Pydantic models are used under the hood to validate the data returned from the API.</p> Source code in <code>farcaster/client.py</code> <pre><code>class Warpcast:\n\"\"\"The Warpcast class is a wrapper around the Farcaster API.\n    It also provides a number of helpful methods and utilities for interacting with the protocol.\n    Pydantic models are used under the hood to validate the data returned from the API.\n    \"\"\"\nconfig: ConfigurationParams\nwallet: Optional[LocalAccount]\naccess_token: NoneStr\nexpires_at: Optional[PositiveInt]\nrotation_duration: PositiveInt\nsession: requests.Session\ndef __init__(\nself,\nmnemonic: NoneStr = None,\nprivate_key: NoneStr = None,\naccess_token: NoneStr = None,\nexpires_at: Optional[PositiveInt] = None,\nrotation_duration: PositiveInt = 10,\n**data: Any,\n):\nself.config = ConfigurationParams(**data)\nself.wallet = get_wallet(mnemonic, private_key)\nself.access_token = access_token\nself.expires_at = expires_at\nself.rotation_duration = rotation_duration\nself.session = requests.Session()\nself.session.mount(\nself.config.base_path,\nHTTPAdapter(\nmax_retries=Retry(\ntotal=2, backoff_factor=1, status_forcelist=[520, 413, 429, 503]\n)\n),\n)\nif self.access_token:\nself.session.headers.update(\n{\"Authorization\": f\"Bearer {self.access_token}\"}\n)\nif not self.expires_at:\nself.expires_at = 33228645430000  # 3000-01-01\nelif not self.wallet:\nraise Exception(\"No wallet or access token provided\")\nelse:\nself.create_new_auth_token(expires_in=self.rotation_duration)\ndef get_base_path(self):\nreturn self.config.base_path\ndef get_base_options(self):\nreturn self.config.base_options\ndef _get(\nself,\npath: str,\nparams: Dict[Any, Any] = {},\njson: Dict[Any, Any] = {},\nheaders: Dict[Any, Any] = {},\n) -&gt; Dict[Any, Any]:\nself._check_auth_header()\nlogging.debug(f\"GET {path} {params} {json} {headers}\")\nresponse: Dict[Any, Any] = self.session.get(\nself.config.base_path + path, params=params, json=json, headers=headers\n).json()\nif \"errors\" in response:\nraise Exception(response[\"errors\"])  # pragma: no cover\nreturn response\ndef _post(\nself,\npath: str,\nparams: Dict[Any, Any] = {},\njson: Dict[Any, Any] = {},\nheaders: Dict[Any, Any] = {},\n) -&gt; Dict[Any, Any]:\nself._check_auth_header()\nlogging.debug(f\"POST {path} {params} {json} {headers}\")\nresponse: Dict[Any, Any] = self.session.post(\nself.config.base_path + path, params=params, json=json, headers=headers\n).json()\nif \"errors\" in response:\nraise Exception(response[\"errors\"])  # pragma: no cover\nreturn response\ndef _put(\nself,\npath: str,\nparams: Dict[Any, Any] = {},\njson: Dict[Any, Any] = {},\nheaders: Dict[Any, Any] = {},\n) -&gt; Dict[Any, Any]:\nself._check_auth_header()\nlogging.debug(f\"PUT {path} {params} {json} {headers}\")\nresponse: Dict[Any, Any] = self.session.put(\nself.config.base_path + path, params=params, json=json, headers=headers\n).json()\nif \"errors\" in response:\nraise Exception(response[\"errors\"])  # pragma: no cover\nreturn response\ndef _delete(\nself,\npath: str,\nparams: Dict[Any, Any] = {},\njson: Dict[Any, Any] = {},\nheaders: Dict[Any, Any] = {},\n) -&gt; Dict[Any, Any]:\nself._check_auth_header()\nlogging.debug(f\"DELETE {path} {params} {json} {headers}\")\nresponse: Dict[Any, Any] = self.session.delete(\nself.config.base_path + path, params=params, json=json, headers=headers\n).json()\nif \"errors\" in response:\nraise Exception(response[\"errors\"])  # pragma: no cover\nreturn response\ndef _check_auth_header(self):\nassert self.expires_at\nif self.expires_at &lt; now_ms() + 1000:\nself.create_new_auth_token(expires_in=self.rotation_duration)\ndef get_healthcheck(self) -&gt; bool:\n\"\"\"Check if API is up and running\n        Returns:\n            bool: Status of the API\n        \"\"\"\nresponse = self.session.get(\"https://api.warpcast.com/healthcheck\")\nreturn response.ok\ndef get_asset(self, token_id: int) -&gt; AssetResult:\n\"\"\"Get asset information\n        Args:\n            token_id (int): token ID\n        Returns:\n            AssetResult: token information\n        \"\"\"\nresponse = self._get(\"asset\", {\"token_id\": token_id})\nreturn AssetGetResponse(**response).result\ndef get_asset_events(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableEventsResult:\n\"\"\"Get events for a given asset\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): events to receive, defaults\n                to 25\n        Returns:\n            IterableEventsResult: Returns the EventsResult model with an optional cursor\n        \"\"\"\nresponse = AssetEventsGetResponse(\n**self._get(\n\"asset-events\",\nparams={\"cursor\": cursor, \"limit\": limit},\n)\n)\nreturn IterableEventsResult(\nevents=response.result.events, cursor=getattr(response.next, \"cursor\", None)\n)\ndef put_auth(self, auth_params: AuthParams) -&gt; TokenResult:\n\"\"\"Generate a custody bearer token and use it to generate an access token\n        Args:\n            auth_params (AuthParams): _description_\n        Returns:\n            TokenResult: _description_\n        \"\"\"\nheader = self.generate_custody_auth_header(auth_params)\nbody = AuthPutRequest(params=auth_params)\nresponse = requests.put(\nself.config.base_path + \"auth\",\njson=body.dict(by_alias=True, exclude_none=True),\nheaders={\"Authorization\": header},\n).json()\nreturn AuthPutResponse(**response).result\ndef delete_auth(self) -&gt; StatusContent:\n\"\"\"Delete an access token\n        Returns:\n            StatusContent: Status of the deletion\n        \"\"\"\ntimestamp = now_ms()\nbody = AuthDeleteRequest(params=Timestamp(timestamp=timestamp))\nresponse = self._delete(\n\"auth\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\ndef get_cast_likes(\nself,\ncast_hash: str,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableReactionsResult:\n\"\"\"Get the likes for a given cast\n        Args:\n            cast_hash (str): cast hash\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableReactionsResult: Model containing the likes with an optional cursor\n        \"\"\"\nlikes: List[ApiCastReaction] = []\nwhile True:\nresponse = self._get(\n\"cast-likes\",\nparams={\n\"castHash\": cast_hash,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = CastReactionsGetResponse(**response)\nif response_model.result.likes:\nlikes = response_model.result.likes\nif not response_model.next or len(likes) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableReactionsResult(\nlikes=likes[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef like_cast(self, cast_hash: str) -&gt; ReactionsPutResult:\n\"\"\"Like a given cast\n        Args:\n            cast_hash (str): hash of the cast to like\n        Returns:\n            ReactionsPutResult: Result of liking the cast\n        \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._put(\n\"cast-likes\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn CastReactionsPutResponse(**response).result\ndef delete_cast_likes(self, cast_hash: str) -&gt; StatusContent:\n\"\"\"Remove a like from a cast\n        Args:\n            cast_hash (str): hash of the cast to unlike\n        Returns:\n            StatusContent: Status of the deletion\n        \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._delete(\n\"cast-likes\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\ndef get_cast_recasters(\nself,\ncast_hash: str,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the recasters for a given cast\n        Args:\n            cast_hash (str): cast hash\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableUsersResult: Model containing the recasters with an optional cursor\n        \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"cast-recasters\",\nparams={\n\"castHash\": cast_hash,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = CastRecastersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\nreturn IterableUsersResult(\nusers=users, cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef get_cast(\nself,\nhash: str,\n) -&gt; CastContent:\n\"\"\"Get a specific cast\n        Args:\n            hash (str): cast hash\n        Returns:\n            CastContent: The cast content\n        \"\"\"\nresponse = self._get(\n\"cast\",\nparams={\"hash\": hash},\n)\nreturn CastGetResponse(**response).result\ndef get_all_casts_in_thread(\nself,\nthread_hash: str,\n) -&gt; CastsResult:\n\"\"\"Get all casts in a thread\n        Args:\n            thread_hash (str): hash of the thread\n        Returns:\n            CastsResult: Model containing the casts\n        \"\"\"\nresponse = self._get(\n\"all-casts-in-thread\",\nparams={\"threadHash\": thread_hash},\n)\nreturn CastsGetResponse(**response).result\ndef get_casts(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableCastsResult:\n\"\"\"Get the casts for a given fid of a user\n        Args:\n            fid (int): Farcaster ID of the user\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableCastsResult: Model containing the casts with an optional cursor\n        \"\"\"\ncasts: List[ApiCast] = []\nwhile True:\nresponse = self._get(\n\"casts\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = CastsGetResponse(**response)\nif response_model.result.casts:\ncasts.extend(response_model.result.casts)\nif not response_model.next or len(casts) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableCastsResult(\ncasts=casts[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef post_cast(\nself,\ntext: str,\nembeds: Optional[List[str]] = None,\nparent: Optional[Parent] = None,\n) -&gt; CastContent:\n\"\"\"Post a cast to Farcaster\n        Args:\n            text (str): text of the cast\n            embeds (Optional[List[str]], optional): list of embeds, defaults to None\n            parent (Optional[Parent], optional): parent of the cast, defaults to None\n        Returns:\n            CastContent: The result of posting the cast\n        \"\"\"\nbody = CastsPostRequest(text=text, embeds=embeds, parent=parent)\nresponse = self._post(\n\"casts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn CastsPostResponse(**response).result\ndef delete_cast(self, cast_hash: str) -&gt; StatusContent:\n\"\"\"Delete a cast\n        Args:\n            cast_hash (str): the hash of the cast to delete\n        Returns:\n            StatusContent: Status of the deletion\n        \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._delete(\n\"casts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\ndef get_collection_owners(\nself,\ncollection_id: str,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the owners of an OpenSea collection\n        Args:\n            collection_id (str): OpenSea collection ID\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableUsersResult: model containing users with an optional cursor\n        \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"collection-owners\",\nparams={\n\"collectionId\": collection_id,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = CollectionOwnersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef get_followers(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the followers of a user\n        Args:\n            fid (int): Farcaster ID of the user\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableUsersResult: model containing users with an optional cursor\n        \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"followers\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = FollowersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef get_all_followers(self, fid: Optional[int] = None) -&gt; UsersResult:\n\"\"\"Get all followers of a user by iterating through the next cursors\n        Args:\n            fid (int): Farcaster ID of the user\n        Returns:\n            UsersResult: model containing users\n        \"\"\"\nusers: List[ApiUser] = []\ncursor = None\nlimit = 100\nif fid is None:\nfid = self.get_me().fid\nwhile True:\nresponse = self._get(\n\"followers\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": limit},\n)\nresponse_model = FollowersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif response_model.next is None:\nbreak\ncursor = response_model.next.cursor\nreturn UsersResult(users=users)\ndef get_following(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the users a user is following\n        Args:\n            fid (int): Farcaster ID of the user\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableUsersResult: model containing users with an optional cursor\n        \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"following\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = FollowingGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef get_all_following(self, fid: Optional[int] = None) -&gt; UsersResult:\n\"\"\"Get all the users a user is following by iterating through the next cursors\n        Args:\n            fid (int): Farcaster ID of the user\n        Returns:\n            UsersResult: model containing users\n        \"\"\"\nusers: List[ApiUser] = []\ncursor = None\nlimit = 100\nif fid is None:\nfid = self.get_me().fid\nwhile True:\nresponse = self._get(\n\"following\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": limit},\n)\nresponse_model = FollowingGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif response_model.next is None:\nbreak\ncursor = response_model.next.cursor\nreturn UsersResult(users=users)\ndef follow_user(self, fid: PositiveInt) -&gt; StatusContent:\n\"\"\"Follow a user\n        Args:\n            fid (PositiveInt): Farcaster ID of the user to follow\n        Returns:\n            StatusContent: Status of the follow\n        \"\"\"\nbody = FollowsPutRequest(target_fid=fid)\nresponse = self._put(\n\"follows\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\ndef unfollow_user(self, fid: PositiveInt) -&gt; StatusContent:\n\"\"\"Unfollow a user\n        Args:\n            fid (PositiveInt): Farcaster ID of the user to unfollow\n        Returns:\n            StatusContent: Status of the unfollow\n        \"\"\"\nbody = FollowsDeleteRequest(target_fid=fid)\nresponse = self._delete(\n\"follows\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\ndef get_me(self) -&gt; ApiUser:\n\"\"\"Get the current user\n        Returns:\n            ApiUser: model containing the current user\n        \"\"\"\nresponse = self._get(\n\"me\",\n)\nresponse_model = MeGetResponse(**response).result\nself.config.username = response_model.user.username\nreturn response_model.user\ndef get_mention_and_reply_notifications(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableNotificationsResult:\n\"\"\"Get mention and reply notifications\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableNotificationsResult: model containing notifications with an optional cursor\n        \"\"\"\nnotifications: List[Union[MentionNotification, ReplyNotification]] = []\nwhile True:\nresponse = self._get(\n\"mention-and-reply-notifications\",\nparams={\"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = MentionAndReplyNotificationsGetResponse(**response)\nif response_model.result.notifications:\nnotifications.extend(response_model.result.notifications)\nif not response_model.next or len(notifications) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableNotificationsResult(\nnotifications=notifications[:limit],\ncursor=getattr(response_model.next, \"cursor\", None),\n)\ndef _recent_notifications_list(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; List[Union[MentionNotification, ReplyNotification]]:\n\"\"\"Get mention and reply notifications as a list\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25\n        Returns:\n            List[Union[MentionNotification, ReplyNotification]]: list of notifications\n        \"\"\"\nreturn self.get_mention_and_reply_notifications(\ncursor=cursor, limit=limit\n).notifications\ndef stream_notifications(\nself, **stream_options: Any\n) -&gt; Iterator[Optional[Union[MentionNotification, ReplyNotification]]]:\n\"\"\"Stream all recent notifications\n        Possible stream options:\n            ``pause_after``: ``Optional[int]`` = ``None``, The number of times to call the API without finding a new item\n            ``skip_existing``: ``bool`` = ``False``, If ``True``, skip items that existed before the stream was created\n            ``max_counter``: ``PositiveInt`` = ``16``, The maximum number of seconds to wait between calls to the API\n        Args:\n            **stream_options: stream options\n        Returns:\n            Iterator[Optional[Union[MentionNotification, ReplyNotification]]]: iterator of notifications. Returns none if pause_after is reached\n        \"\"\"\nreturn stream_generator(\nself._recent_notifications_list,\nattribute_name=\"id\",\nlimit=20,\n**stream_options,\n)\ndef recast(self, cast_hash: str) -&gt; CastHash:\n\"\"\"Recast a cast\n        Args:\n            cast_hash (str): the cast hash\n        Returns:\n            CastHash: model containing the cast hash\n        \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._put(\n\"recasts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn RecastsPutResponse(**response).result\ndef delete_recast(self, cast_hash: str) -&gt; StatusContent:\n\"\"\"Delete a recast\n        Args:\n            cast_hash (str): the cast hash\n        Returns:\n            StatusContent: Status of the recast deletion\n        \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._delete(\n\"recasts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\ndef get_user(self, fid: int) -&gt; ApiUser:\n\"\"\"Get a user\n        Args:\n            fid (int): Farcaster ID of the user\n        Returns:\n            ApiUser: model containing the user\n        \"\"\"\nresponse = self._get(\n\"user\",\nparams={\"fid\": fid},\n)\nreturn UserGetResponse(**response).result.user\ndef get_user_by_username(\nself,\nusername: str,\n) -&gt; ApiUser:\n\"\"\"Get a user by username\n        Args:\n            username (str): username of the user\n        Returns:\n            ApiUser: model containing the user\n        \"\"\"\nresponse = self._get(\n\"user-by-username\",\nparams={\"username\": username},\n)\nreturn UserByUsernameGetResponse(**response).result.user\ndef get_user_by_verification(\nself,\naddress: str,\n) -&gt; ApiUser:\n\"\"\"Get a user by verification address\n        Args:\n            address (str): address of the user\n        Returns:\n            ApiUser: model containing the user\n        \"\"\"\nresponse = self._get(\n\"user-by-verification\",\nparams={\"address\": address},\n)\nreturn UserByUsernameGetResponse(**response).result.user\ndef get_user_collections(\nself,\nowner_fid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableCollectionsResult:\n\"\"\"Get the collections of a user\n        Args:\n            owner_fid (int): Farcaster ID of the user\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableCollectionsResult: model containing collections with an optional cursor\n        \"\"\"\ncollections: List[ApiAssetCollection] = []\nwhile True:\nresponse = self._get(\n\"user-collections\",\nparams={\n\"ownerFid\": owner_fid,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = UserCollectionsGetResponse(**response)\nif response_model.result.collections:\ncollections.extend(response_model.result.collections)\nif not response_model.next or len(collections) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableCollectionsResult(\ncollections=collections[:limit],\ncursor=getattr(response_model.next, \"cursor\", None),\n)\ndef get_verifications(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableVerificationsResult:\n\"\"\"Get the verifications of a user\n        Args:\n            fid (int): Farcaster ID of the user\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25\n        Returns:\n            IterableVerificationsResult: model containing verifications with an optional cursor\n        \"\"\"\nresponse = VerificationsGetResponse(\n**self._get(\n\"verifications\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": limit},\n)\n)\nreturn IterableVerificationsResult(\nverifications=response.result.verifications,\ncursor=getattr(response.next, \"cursor\", None),\n)\ndef get_recent_users(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get recent users\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableUsersResult: model containing users with an optional cursor\n        \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"recent-users\",\nparams={\"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = UsersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef _recent_users_list(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; List[ApiUser]:\n\"\"\"Get recent users as a list\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25\n        Returns:\n            List[ApiUser]: list of users\n        \"\"\"\nreturn self.get_recent_users(cursor=cursor, limit=limit).users\ndef stream_users(self, **stream_options: Any) -&gt; Iterator[Optional[ApiUser]]:\n\"\"\"Stream all recent users.\n        Possible stream options:\n            ``pause_after``: ``Optional[int]`` = ``None``, The number of times to call the API without finding a new item\n            ``skip_existing``: ``bool`` = ``False``, If ``True``, skip items that existed before the stream was created\n            ``max_counter``: ``PositiveInt`` = ``16``, The maximum number of seconds to wait between calls to the API\n        Args:\n            **stream_options: stream options\n        Returns:\n            Iterator[Optional[ApiUser]]: iterator of users. Returns none if pause_after is reached\n        \"\"\"\nreturn stream_generator(\nself._recent_users_list, attribute_name=\"fid\", limit=20, **stream_options\n)\ndef get_custody_address(\nself,\nusername: NoneStr = None,\nfid: Optional[int] = None,\n) -&gt; CustodyAddress:\n\"\"\"Get the custody address of a user\n        Args:\n            username (NoneStr, optional): username of a user, defaults\n                to None\n            fid (Optional[int], optional): Farcaster ID, defaults to\n                None\n        Returns:\n            CustodyAddress: model containing the custody address\n        \"\"\"\nassert username or fid, \"fname or fid must be provided\"\nresponse = self._get(\n\"custody-address\",\nparams={\"fname\": username, \"fid\": fid},\n)\nreturn CustodyAddressGetResponse(**response).result\ndef get_user_cast_likes(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableLikes:\n\"\"\"Get the likes of a user\n        Args:\n            fid (int): Farcaster ID of the user\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n        Returns:\n            IterableLikes: model containing likes with an optional cursor\n        \"\"\"\nlikes: List[ApiCastReaction] = []\nwhile True:\nresponse = self._get(\n\"user-cast-likes\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = UserCastLikesGetResponse(**response)\nif response_model.result.likes:\nlikes.extend(response_model.result.likes)\nif not response_model.next or len(likes) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableLikes(\nlikes=likes[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef get_recent_casts(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 100,\n) -&gt; IterableCastsResult:\n\"\"\"Get all recent casts\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 100\n        Returns:\n            IterableCastsResult: model containing casts with an optional cursor\n        \"\"\"\ncasts: List[ApiCast] = []\nwhile True:\nresponse = self._get(\n\"recent-casts\",\nparams={\"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = CastsGetResponse(**response)\nif response_model.result.casts:\ncasts.extend(response_model.result.casts)\nif not response_model.next or len(casts) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableCastsResult(\ncasts=casts[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\ndef _recent_casts_lists(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 100,\n) -&gt; List[ApiCast]:\n\"\"\"Get all recent casts and return them as a list\n        Args:\n            cursor (NoneStr, optional): cursor, defaults to None\n            limit (PositiveInt, optional): limit, defaults to 100\n        Returns:\n            List[ApiCast]: list of casts\n        \"\"\"\nreturn self.get_recent_casts(cursor=cursor, limit=limit).casts\ndef stream_casts(self, **stream_options: Any) -&gt; Iterator[Optional[ApiCast]]:\n\"\"\"Stream all recent casts\n        Possible stream options:\n            ``pause_after``: ``Optional[int]`` = ``None``, The number of times to call the API without finding a new item\n            ``skip_existing``: ``bool`` = ``False``, If ``True``, skip items that existed before the stream was created\n            ``max_counter``: ``PositiveInt`` = ``16``, The maximum number of seconds to wait between calls to the API\n        Args:\n            **stream_options: stream options\n        Returns:\n            Iterator[Optional[ApiCast]]: iterator of casts. Returns none if pause_after is reached\n        \"\"\"\nreturn stream_generator(\nself._recent_casts_lists, attribute_name=\"hash\", limit=50, **stream_options\n)\ndef create_new_auth_token(self, expires_in: PositiveInt = 10) -&gt; str:\n\"\"\"Create a new access token for a user from the wallet credentials\n        Args:\n            expires_in (PositiveInt): Expiration length of the token in minutes,\n                defaults to 10 minutes\n        Returns:\n            str: access token\n        \"\"\"\nnow = int(time.time())\nauth_params = AuthParams(\ntimestamp=now * 1000, expires_at=(now + (expires_in * 60)) * 1000\n)\nlogging.debug(f\"Creating new auth token with params: {auth_params}\")\nresponse = self.put_auth(auth_params)\nself.access_token = response.token.secret\nself.expires_at = auth_params.expires_at\nself.rotation_duration = expires_in\nself.session.headers.update({\"Authorization\": f\"Bearer {self.access_token}\"})\nreturn self.access_token\ndef generate_custody_auth_header(self, params: AuthParams) -&gt; str:\n\"\"\"Generate a custody authorization header. Usually invoked from create_new_auth_token.\n        Args:\n            params (AuthParams): authorization parameters\n        Raises:\n            Exception: Wallet is required\n        Returns:\n            str: custody authorization header\n        \"\"\"\nif not self.wallet:\nraise Exception(\"Wallet not set\")\nauth_put_request = AuthPutRequest(params=params)\npayload = auth_put_request.dict(by_alias=True, exclude_none=True)\nencoded_payload = canonicaljson.encode_canonical_json(payload)\nsignable_message = encode_defunct(primitive=encoded_payload)\nsigned_message: SignedMessage = self.wallet.sign_message(signable_message)\ndata_hex_array = bytearray(signed_message.signature)\nencoded = base64.b64encode(data_hex_array).decode()\nreturn f\"Bearer eip191:{encoded}\"\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.create_new_auth_token","title":"<code>create_new_auth_token(expires_in=10)</code>","text":"<p>Create a new access token for a user from the wallet credentials</p> <p>Parameters:</p> Name Type Description Default <code>expires_in</code> <code>PositiveInt</code> <p>Expiration length of the token in minutes, defaults to 10 minutes</p> <code>10</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>access token</p> Source code in <code>farcaster/client.py</code> <pre><code>def create_new_auth_token(self, expires_in: PositiveInt = 10) -&gt; str:\n\"\"\"Create a new access token for a user from the wallet credentials\n    Args:\n        expires_in (PositiveInt): Expiration length of the token in minutes,\n            defaults to 10 minutes\n    Returns:\n        str: access token\n    \"\"\"\nnow = int(time.time())\nauth_params = AuthParams(\ntimestamp=now * 1000, expires_at=(now + (expires_in * 60)) * 1000\n)\nlogging.debug(f\"Creating new auth token with params: {auth_params}\")\nresponse = self.put_auth(auth_params)\nself.access_token = response.token.secret\nself.expires_at = auth_params.expires_at\nself.rotation_duration = expires_in\nself.session.headers.update({\"Authorization\": f\"Bearer {self.access_token}\"})\nreturn self.access_token\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.delete_auth","title":"<code>delete_auth()</code>","text":"<p>Delete an access token</p> <p>Returns:</p> Name Type Description <code>StatusContent</code> <code>StatusContent</code> <p>Status of the deletion</p> Source code in <code>farcaster/client.py</code> <pre><code>def delete_auth(self) -&gt; StatusContent:\n\"\"\"Delete an access token\n    Returns:\n        StatusContent: Status of the deletion\n    \"\"\"\ntimestamp = now_ms()\nbody = AuthDeleteRequest(params=Timestamp(timestamp=timestamp))\nresponse = self._delete(\n\"auth\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.delete_cast","title":"<code>delete_cast(cast_hash)</code>","text":"<p>Delete a cast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>the hash of the cast to delete</p> required <p>Returns:</p> Name Type Description <code>StatusContent</code> <code>StatusContent</code> <p>Status of the deletion</p> Source code in <code>farcaster/client.py</code> <pre><code>def delete_cast(self, cast_hash: str) -&gt; StatusContent:\n\"\"\"Delete a cast\n    Args:\n        cast_hash (str): the hash of the cast to delete\n    Returns:\n        StatusContent: Status of the deletion\n    \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._delete(\n\"casts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.delete_cast_likes","title":"<code>delete_cast_likes(cast_hash)</code>","text":"<p>Remove a like from a cast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>hash of the cast to unlike</p> required <p>Returns:</p> Name Type Description <code>StatusContent</code> <code>StatusContent</code> <p>Status of the deletion</p> Source code in <code>farcaster/client.py</code> <pre><code>def delete_cast_likes(self, cast_hash: str) -&gt; StatusContent:\n\"\"\"Remove a like from a cast\n    Args:\n        cast_hash (str): hash of the cast to unlike\n    Returns:\n        StatusContent: Status of the deletion\n    \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._delete(\n\"cast-likes\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.delete_recast","title":"<code>delete_recast(cast_hash)</code>","text":"<p>Delete a recast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>the cast hash</p> required <p>Returns:</p> Name Type Description <code>StatusContent</code> <code>StatusContent</code> <p>Status of the recast deletion</p> Source code in <code>farcaster/client.py</code> <pre><code>def delete_recast(self, cast_hash: str) -&gt; StatusContent:\n\"\"\"Delete a recast\n    Args:\n        cast_hash (str): the cast hash\n    Returns:\n        StatusContent: Status of the recast deletion\n    \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._delete(\n\"recasts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.follow_user","title":"<code>follow_user(fid)</code>","text":"<p>Follow a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>PositiveInt</code> <p>Farcaster ID of the user to follow</p> required <p>Returns:</p> Name Type Description <code>StatusContent</code> <code>StatusContent</code> <p>Status of the follow</p> Source code in <code>farcaster/client.py</code> <pre><code>def follow_user(self, fid: PositiveInt) -&gt; StatusContent:\n\"\"\"Follow a user\n    Args:\n        fid (PositiveInt): Farcaster ID of the user to follow\n    Returns:\n        StatusContent: Status of the follow\n    \"\"\"\nbody = FollowsPutRequest(target_fid=fid)\nresponse = self._put(\n\"follows\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.generate_custody_auth_header","title":"<code>generate_custody_auth_header(params)</code>","text":"<p>Generate a custody authorization header. Usually invoked from create_new_auth_token.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>AuthParams</code> <p>authorization parameters</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Wallet is required</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>custody authorization header</p> Source code in <code>farcaster/client.py</code> <pre><code>def generate_custody_auth_header(self, params: AuthParams) -&gt; str:\n\"\"\"Generate a custody authorization header. Usually invoked from create_new_auth_token.\n    Args:\n        params (AuthParams): authorization parameters\n    Raises:\n        Exception: Wallet is required\n    Returns:\n        str: custody authorization header\n    \"\"\"\nif not self.wallet:\nraise Exception(\"Wallet not set\")\nauth_put_request = AuthPutRequest(params=params)\npayload = auth_put_request.dict(by_alias=True, exclude_none=True)\nencoded_payload = canonicaljson.encode_canonical_json(payload)\nsignable_message = encode_defunct(primitive=encoded_payload)\nsigned_message: SignedMessage = self.wallet.sign_message(signable_message)\ndata_hex_array = bytearray(signed_message.signature)\nencoded = base64.b64encode(data_hex_array).decode()\nreturn f\"Bearer eip191:{encoded}\"\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_all_casts_in_thread","title":"<code>get_all_casts_in_thread(thread_hash)</code>","text":"<p>Get all casts in a thread</p> <p>Parameters:</p> Name Type Description Default <code>thread_hash</code> <code>str</code> <p>hash of the thread</p> required <p>Returns:</p> Name Type Description <code>CastsResult</code> <code>CastsResult</code> <p>Model containing the casts</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_all_casts_in_thread(\nself,\nthread_hash: str,\n) -&gt; CastsResult:\n\"\"\"Get all casts in a thread\n    Args:\n        thread_hash (str): hash of the thread\n    Returns:\n        CastsResult: Model containing the casts\n    \"\"\"\nresponse = self._get(\n\"all-casts-in-thread\",\nparams={\"threadHash\": thread_hash},\n)\nreturn CastsGetResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_all_followers","title":"<code>get_all_followers(fid=None)</code>","text":"<p>Get all followers of a user by iterating through the next cursors</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> <code>None</code> <p>Returns:</p> Name Type Description <code>UsersResult</code> <code>UsersResult</code> <p>model containing users</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_all_followers(self, fid: Optional[int] = None) -&gt; UsersResult:\n\"\"\"Get all followers of a user by iterating through the next cursors\n    Args:\n        fid (int): Farcaster ID of the user\n    Returns:\n        UsersResult: model containing users\n    \"\"\"\nusers: List[ApiUser] = []\ncursor = None\nlimit = 100\nif fid is None:\nfid = self.get_me().fid\nwhile True:\nresponse = self._get(\n\"followers\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": limit},\n)\nresponse_model = FollowersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif response_model.next is None:\nbreak\ncursor = response_model.next.cursor\nreturn UsersResult(users=users)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_all_following","title":"<code>get_all_following(fid=None)</code>","text":"<p>Get all the users a user is following by iterating through the next cursors</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> <code>None</code> <p>Returns:</p> Name Type Description <code>UsersResult</code> <code>UsersResult</code> <p>model containing users</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_all_following(self, fid: Optional[int] = None) -&gt; UsersResult:\n\"\"\"Get all the users a user is following by iterating through the next cursors\n    Args:\n        fid (int): Farcaster ID of the user\n    Returns:\n        UsersResult: model containing users\n    \"\"\"\nusers: List[ApiUser] = []\ncursor = None\nlimit = 100\nif fid is None:\nfid = self.get_me().fid\nwhile True:\nresponse = self._get(\n\"following\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": limit},\n)\nresponse_model = FollowingGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif response_model.next is None:\nbreak\ncursor = response_model.next.cursor\nreturn UsersResult(users=users)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_asset","title":"<code>get_asset(token_id)</code>","text":"<p>Get asset information</p> <p>Parameters:</p> Name Type Description Default <code>token_id</code> <code>int</code> <p>token ID</p> required <p>Returns:</p> Name Type Description <code>AssetResult</code> <code>AssetResult</code> <p>token information</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_asset(self, token_id: int) -&gt; AssetResult:\n\"\"\"Get asset information\n    Args:\n        token_id (int): token ID\n    Returns:\n        AssetResult: token information\n    \"\"\"\nresponse = self._get(\"asset\", {\"token_id\": token_id})\nreturn AssetGetResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_asset_events","title":"<code>get_asset_events(cursor=None, limit=25)</code>","text":"<p>Get events for a given asset</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>events to receive, defaults to 25</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableEventsResult</code> <code>IterableEventsResult</code> <p>Returns the EventsResult model with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_asset_events(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableEventsResult:\n\"\"\"Get events for a given asset\n    Args:\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): events to receive, defaults\n            to 25\n    Returns:\n        IterableEventsResult: Returns the EventsResult model with an optional cursor\n    \"\"\"\nresponse = AssetEventsGetResponse(\n**self._get(\n\"asset-events\",\nparams={\"cursor\": cursor, \"limit\": limit},\n)\n)\nreturn IterableEventsResult(\nevents=response.result.events, cursor=getattr(response.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_cast","title":"<code>get_cast(hash)</code>","text":"<p>Get a specific cast</p> <p>Parameters:</p> Name Type Description Default <code>hash</code> <code>str</code> <p>cast hash</p> required <p>Returns:</p> Name Type Description <code>CastContent</code> <code>CastContent</code> <p>The cast content</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_cast(\nself,\nhash: str,\n) -&gt; CastContent:\n\"\"\"Get a specific cast\n    Args:\n        hash (str): cast hash\n    Returns:\n        CastContent: The cast content\n    \"\"\"\nresponse = self._get(\n\"cast\",\nparams={\"hash\": hash},\n)\nreturn CastGetResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_cast_likes","title":"<code>get_cast_likes(cast_hash, cursor=None, limit=25)</code>","text":"<p>Get the likes for a given cast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>cast hash</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableReactionsResult</code> <code>IterableReactionsResult</code> <p>Model containing the likes with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_cast_likes(\nself,\ncast_hash: str,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableReactionsResult:\n\"\"\"Get the likes for a given cast\n    Args:\n        cast_hash (str): cast hash\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableReactionsResult: Model containing the likes with an optional cursor\n    \"\"\"\nlikes: List[ApiCastReaction] = []\nwhile True:\nresponse = self._get(\n\"cast-likes\",\nparams={\n\"castHash\": cast_hash,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = CastReactionsGetResponse(**response)\nif response_model.result.likes:\nlikes = response_model.result.likes\nif not response_model.next or len(likes) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableReactionsResult(\nlikes=likes[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_cast_recasters","title":"<code>get_cast_recasters(cast_hash, cursor=None, limit=25)</code>","text":"<p>Get the recasters for a given cast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>cast hash</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableUsersResult</code> <code>IterableUsersResult</code> <p>Model containing the recasters with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_cast_recasters(\nself,\ncast_hash: str,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the recasters for a given cast\n    Args:\n        cast_hash (str): cast hash\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableUsersResult: Model containing the recasters with an optional cursor\n    \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"cast-recasters\",\nparams={\n\"castHash\": cast_hash,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = CastRecastersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\nreturn IterableUsersResult(\nusers=users, cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_casts","title":"<code>get_casts(fid, cursor=None, limit=25)</code>","text":"<p>Get the casts for a given fid of a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableCastsResult</code> <code>IterableCastsResult</code> <p>Model containing the casts with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_casts(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableCastsResult:\n\"\"\"Get the casts for a given fid of a user\n    Args:\n        fid (int): Farcaster ID of the user\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableCastsResult: Model containing the casts with an optional cursor\n    \"\"\"\ncasts: List[ApiCast] = []\nwhile True:\nresponse = self._get(\n\"casts\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = CastsGetResponse(**response)\nif response_model.result.casts:\ncasts.extend(response_model.result.casts)\nif not response_model.next or len(casts) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableCastsResult(\ncasts=casts[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_collection_owners","title":"<code>get_collection_owners(collection_id, cursor=None, limit=25)</code>","text":"<p>Get the owners of an OpenSea collection</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>OpenSea collection ID</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableUsersResult</code> <code>IterableUsersResult</code> <p>model containing users with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_collection_owners(\nself,\ncollection_id: str,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the owners of an OpenSea collection\n    Args:\n        collection_id (str): OpenSea collection ID\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableUsersResult: model containing users with an optional cursor\n    \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"collection-owners\",\nparams={\n\"collectionId\": collection_id,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = CollectionOwnersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_custody_address","title":"<code>get_custody_address(username=None, fid=None)</code>","text":"<p>Get the custody address of a user</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>NoneStr</code> <p>username of a user, defaults to None</p> <code>None</code> <code>fid</code> <code>Optional[int]</code> <p>Farcaster ID, defaults to None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CustodyAddress</code> <code>CustodyAddress</code> <p>model containing the custody address</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_custody_address(\nself,\nusername: NoneStr = None,\nfid: Optional[int] = None,\n) -&gt; CustodyAddress:\n\"\"\"Get the custody address of a user\n    Args:\n        username (NoneStr, optional): username of a user, defaults\n            to None\n        fid (Optional[int], optional): Farcaster ID, defaults to\n            None\n    Returns:\n        CustodyAddress: model containing the custody address\n    \"\"\"\nassert username or fid, \"fname or fid must be provided\"\nresponse = self._get(\n\"custody-address\",\nparams={\"fname\": username, \"fid\": fid},\n)\nreturn CustodyAddressGetResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_followers","title":"<code>get_followers(fid, cursor=None, limit=25)</code>","text":"<p>Get the followers of a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableUsersResult</code> <code>IterableUsersResult</code> <p>model containing users with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_followers(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the followers of a user\n    Args:\n        fid (int): Farcaster ID of the user\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableUsersResult: model containing users with an optional cursor\n    \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"followers\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = FollowersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_following","title":"<code>get_following(fid, cursor=None, limit=25)</code>","text":"<p>Get the users a user is following</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableUsersResult</code> <code>IterableUsersResult</code> <p>model containing users with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_following(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get the users a user is following\n    Args:\n        fid (int): Farcaster ID of the user\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableUsersResult: model containing users with an optional cursor\n    \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"following\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = FollowingGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_healthcheck","title":"<code>get_healthcheck()</code>","text":"<p>Check if API is up and running</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Status of the API</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_healthcheck(self) -&gt; bool:\n\"\"\"Check if API is up and running\n    Returns:\n        bool: Status of the API\n    \"\"\"\nresponse = self.session.get(\"https://api.warpcast.com/healthcheck\")\nreturn response.ok\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_me","title":"<code>get_me()</code>","text":"<p>Get the current user</p> <p>Returns:</p> Name Type Description <code>ApiUser</code> <code>ApiUser</code> <p>model containing the current user</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_me(self) -&gt; ApiUser:\n\"\"\"Get the current user\n    Returns:\n        ApiUser: model containing the current user\n    \"\"\"\nresponse = self._get(\n\"me\",\n)\nresponse_model = MeGetResponse(**response).result\nself.config.username = response_model.user.username\nreturn response_model.user\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_mention_and_reply_notifications","title":"<code>get_mention_and_reply_notifications(cursor=None, limit=25)</code>","text":"<p>Get mention and reply notifications</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableNotificationsResult</code> <code>IterableNotificationsResult</code> <p>model containing notifications with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_mention_and_reply_notifications(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableNotificationsResult:\n\"\"\"Get mention and reply notifications\n    Args:\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableNotificationsResult: model containing notifications with an optional cursor\n    \"\"\"\nnotifications: List[Union[MentionNotification, ReplyNotification]] = []\nwhile True:\nresponse = self._get(\n\"mention-and-reply-notifications\",\nparams={\"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = MentionAndReplyNotificationsGetResponse(**response)\nif response_model.result.notifications:\nnotifications.extend(response_model.result.notifications)\nif not response_model.next or len(notifications) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableNotificationsResult(\nnotifications=notifications[:limit],\ncursor=getattr(response_model.next, \"cursor\", None),\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_recent_casts","title":"<code>get_recent_casts(cursor=None, limit=100)</code>","text":"<p>Get all recent casts</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 100</p> <code>100</code> <p>Returns:</p> Name Type Description <code>IterableCastsResult</code> <code>IterableCastsResult</code> <p>model containing casts with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_recent_casts(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 100,\n) -&gt; IterableCastsResult:\n\"\"\"Get all recent casts\n    Args:\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 100\n    Returns:\n        IterableCastsResult: model containing casts with an optional cursor\n    \"\"\"\ncasts: List[ApiCast] = []\nwhile True:\nresponse = self._get(\n\"recent-casts\",\nparams={\"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = CastsGetResponse(**response)\nif response_model.result.casts:\ncasts.extend(response_model.result.casts)\nif not response_model.next or len(casts) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableCastsResult(\ncasts=casts[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_recent_users","title":"<code>get_recent_users(cursor=None, limit=25)</code>","text":"<p>Get recent users</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableUsersResult</code> <code>IterableUsersResult</code> <p>model containing users with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_recent_users(\nself,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableUsersResult:\n\"\"\"Get recent users\n    Args:\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableUsersResult: model containing users with an optional cursor\n    \"\"\"\nusers: List[ApiUser] = []\nwhile True:\nresponse = self._get(\n\"recent-users\",\nparams={\"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = UsersGetResponse(**response)\nif response_model.result.users:\nusers.extend(response_model.result.users)\nif not response_model.next or len(users) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableUsersResult(\nusers=users[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_user","title":"<code>get_user(fid)</code>","text":"<p>Get a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <p>Returns:</p> Name Type Description <code>ApiUser</code> <code>ApiUser</code> <p>model containing the user</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_user(self, fid: int) -&gt; ApiUser:\n\"\"\"Get a user\n    Args:\n        fid (int): Farcaster ID of the user\n    Returns:\n        ApiUser: model containing the user\n    \"\"\"\nresponse = self._get(\n\"user\",\nparams={\"fid\": fid},\n)\nreturn UserGetResponse(**response).result.user\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_user_by_username","title":"<code>get_user_by_username(username)</code>","text":"<p>Get a user by username</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>username of the user</p> required <p>Returns:</p> Name Type Description <code>ApiUser</code> <code>ApiUser</code> <p>model containing the user</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_user_by_username(\nself,\nusername: str,\n) -&gt; ApiUser:\n\"\"\"Get a user by username\n    Args:\n        username (str): username of the user\n    Returns:\n        ApiUser: model containing the user\n    \"\"\"\nresponse = self._get(\n\"user-by-username\",\nparams={\"username\": username},\n)\nreturn UserByUsernameGetResponse(**response).result.user\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_user_by_verification","title":"<code>get_user_by_verification(address)</code>","text":"<p>Get a user by verification address</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>address of the user</p> required <p>Returns:</p> Name Type Description <code>ApiUser</code> <code>ApiUser</code> <p>model containing the user</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_user_by_verification(\nself,\naddress: str,\n) -&gt; ApiUser:\n\"\"\"Get a user by verification address\n    Args:\n        address (str): address of the user\n    Returns:\n        ApiUser: model containing the user\n    \"\"\"\nresponse = self._get(\n\"user-by-verification\",\nparams={\"address\": address},\n)\nreturn UserByUsernameGetResponse(**response).result.user\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_user_cast_likes","title":"<code>get_user_cast_likes(fid, cursor=None, limit=25)</code>","text":"<p>Get the likes of a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableLikes</code> <code>IterableLikes</code> <p>model containing likes with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_user_cast_likes(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableLikes:\n\"\"\"Get the likes of a user\n    Args:\n        fid (int): Farcaster ID of the user\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableLikes: model containing likes with an optional cursor\n    \"\"\"\nlikes: List[ApiCastReaction] = []\nwhile True:\nresponse = self._get(\n\"user-cast-likes\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": min(limit, 100)},\n)\nresponse_model = UserCastLikesGetResponse(**response)\nif response_model.result.likes:\nlikes.extend(response_model.result.likes)\nif not response_model.next or len(likes) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableLikes(\nlikes=likes[:limit], cursor=getattr(response_model.next, \"cursor\", None)\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_user_collections","title":"<code>get_user_collections(owner_fid, cursor=None, limit=25)</code>","text":"<p>Get the collections of a user</p> <p>Parameters:</p> Name Type Description Default <code>owner_fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25, otherwise min(limit, 100)</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableCollectionsResult</code> <code>IterableCollectionsResult</code> <p>model containing collections with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_user_collections(\nself,\nowner_fid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableCollectionsResult:\n\"\"\"Get the collections of a user\n    Args:\n        owner_fid (int): Farcaster ID of the user\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25, otherwise min(limit, 100)\n    Returns:\n        IterableCollectionsResult: model containing collections with an optional cursor\n    \"\"\"\ncollections: List[ApiAssetCollection] = []\nwhile True:\nresponse = self._get(\n\"user-collections\",\nparams={\n\"ownerFid\": owner_fid,\n\"cursor\": cursor,\n\"limit\": min(limit, 100),\n},\n)\nresponse_model = UserCollectionsGetResponse(**response)\nif response_model.result.collections:\ncollections.extend(response_model.result.collections)\nif not response_model.next or len(collections) &gt;= limit:\nbreak\ncursor = response_model.next.cursor\nreturn IterableCollectionsResult(\ncollections=collections[:limit],\ncursor=getattr(response_model.next, \"cursor\", None),\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.get_verifications","title":"<code>get_verifications(fid, cursor=None, limit=25)</code>","text":"<p>Get the verifications of a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>int</code> <p>Farcaster ID of the user</p> required <code>cursor</code> <code>NoneStr</code> <p>cursor, defaults to None</p> <code>None</code> <code>limit</code> <code>PositiveInt</code> <p>limit, defaults to 25</p> <code>25</code> <p>Returns:</p> Name Type Description <code>IterableVerificationsResult</code> <code>IterableVerificationsResult</code> <p>model containing verifications with an optional cursor</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_verifications(\nself,\nfid: int,\ncursor: NoneStr = None,\nlimit: PositiveInt = 25,\n) -&gt; IterableVerificationsResult:\n\"\"\"Get the verifications of a user\n    Args:\n        fid (int): Farcaster ID of the user\n        cursor (NoneStr, optional): cursor, defaults to None\n        limit (PositiveInt, optional): limit, defaults to 25\n    Returns:\n        IterableVerificationsResult: model containing verifications with an optional cursor\n    \"\"\"\nresponse = VerificationsGetResponse(\n**self._get(\n\"verifications\",\nparams={\"fid\": fid, \"cursor\": cursor, \"limit\": limit},\n)\n)\nreturn IterableVerificationsResult(\nverifications=response.result.verifications,\ncursor=getattr(response.next, \"cursor\", None),\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.like_cast","title":"<code>like_cast(cast_hash)</code>","text":"<p>Like a given cast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>hash of the cast to like</p> required <p>Returns:</p> Name Type Description <code>ReactionsPutResult</code> <code>ReactionsPutResult</code> <p>Result of liking the cast</p> Source code in <code>farcaster/client.py</code> <pre><code>def like_cast(self, cast_hash: str) -&gt; ReactionsPutResult:\n\"\"\"Like a given cast\n    Args:\n        cast_hash (str): hash of the cast to like\n    Returns:\n        ReactionsPutResult: Result of liking the cast\n    \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._put(\n\"cast-likes\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn CastReactionsPutResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.post_cast","title":"<code>post_cast(text, embeds=None, parent=None)</code>","text":"<p>Post a cast to Farcaster</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>text of the cast</p> required <code>embeds</code> <code>Optional[List[str]]</code> <p>list of embeds, defaults to None</p> <code>None</code> <code>parent</code> <code>Optional[Parent]</code> <p>parent of the cast, defaults to None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CastContent</code> <code>CastContent</code> <p>The result of posting the cast</p> Source code in <code>farcaster/client.py</code> <pre><code>def post_cast(\nself,\ntext: str,\nembeds: Optional[List[str]] = None,\nparent: Optional[Parent] = None,\n) -&gt; CastContent:\n\"\"\"Post a cast to Farcaster\n    Args:\n        text (str): text of the cast\n        embeds (Optional[List[str]], optional): list of embeds, defaults to None\n        parent (Optional[Parent], optional): parent of the cast, defaults to None\n    Returns:\n        CastContent: The result of posting the cast\n    \"\"\"\nbody = CastsPostRequest(text=text, embeds=embeds, parent=parent)\nresponse = self._post(\n\"casts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn CastsPostResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.put_auth","title":"<code>put_auth(auth_params)</code>","text":"<p>Generate a custody bearer token and use it to generate an access token</p> <p>Parameters:</p> Name Type Description Default <code>auth_params</code> <code>AuthParams</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>TokenResult</code> <code>TokenResult</code> <p>description</p> Source code in <code>farcaster/client.py</code> <pre><code>def put_auth(self, auth_params: AuthParams) -&gt; TokenResult:\n\"\"\"Generate a custody bearer token and use it to generate an access token\n    Args:\n        auth_params (AuthParams): _description_\n    Returns:\n        TokenResult: _description_\n    \"\"\"\nheader = self.generate_custody_auth_header(auth_params)\nbody = AuthPutRequest(params=auth_params)\nresponse = requests.put(\nself.config.base_path + \"auth\",\njson=body.dict(by_alias=True, exclude_none=True),\nheaders={\"Authorization\": header},\n).json()\nreturn AuthPutResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.recast","title":"<code>recast(cast_hash)</code>","text":"<p>Recast a cast</p> <p>Parameters:</p> Name Type Description Default <code>cast_hash</code> <code>str</code> <p>the cast hash</p> required <p>Returns:</p> Name Type Description <code>CastHash</code> <code>CastHash</code> <p>model containing the cast hash</p> Source code in <code>farcaster/client.py</code> <pre><code>def recast(self, cast_hash: str) -&gt; CastHash:\n\"\"\"Recast a cast\n    Args:\n        cast_hash (str): the cast hash\n    Returns:\n        CastHash: model containing the cast hash\n    \"\"\"\nbody = CastHash(cast_hash=cast_hash)\nresponse = self._put(\n\"recasts\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn RecastsPutResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.stream_casts","title":"<code>stream_casts(**stream_options)</code>","text":"<p>Stream all recent casts</p> Possible stream options <p><code>pause_after</code>: <code>Optional[int]</code> = <code>None</code>, The number of times to call the API without finding a new item</p> <p><code>skip_existing</code>: <code>bool</code> = <code>False</code>, If <code>True</code>, skip items that existed before the stream was created</p> <p><code>max_counter</code>: <code>PositiveInt</code> = <code>16</code>, The maximum number of seconds to wait between calls to the API</p> <p>Parameters:</p> Name Type Description Default <code>**stream_options</code> <code>Any</code> <p>stream options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterator[Optional[ApiCast]]</code> <p>Iterator[Optional[ApiCast]]: iterator of casts. Returns none if pause_after is reached</p> Source code in <code>farcaster/client.py</code> <pre><code>def stream_casts(self, **stream_options: Any) -&gt; Iterator[Optional[ApiCast]]:\n\"\"\"Stream all recent casts\n    Possible stream options:\n        ``pause_after``: ``Optional[int]`` = ``None``, The number of times to call the API without finding a new item\n        ``skip_existing``: ``bool`` = ``False``, If ``True``, skip items that existed before the stream was created\n        ``max_counter``: ``PositiveInt`` = ``16``, The maximum number of seconds to wait between calls to the API\n    Args:\n        **stream_options: stream options\n    Returns:\n        Iterator[Optional[ApiCast]]: iterator of casts. Returns none if pause_after is reached\n    \"\"\"\nreturn stream_generator(\nself._recent_casts_lists, attribute_name=\"hash\", limit=50, **stream_options\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.stream_notifications","title":"<code>stream_notifications(**stream_options)</code>","text":"<p>Stream all recent notifications</p> Possible stream options <p><code>pause_after</code>: <code>Optional[int]</code> = <code>None</code>, The number of times to call the API without finding a new item</p> <p><code>skip_existing</code>: <code>bool</code> = <code>False</code>, If <code>True</code>, skip items that existed before the stream was created</p> <p><code>max_counter</code>: <code>PositiveInt</code> = <code>16</code>, The maximum number of seconds to wait between calls to the API</p> <p>Parameters:</p> Name Type Description Default <code>**stream_options</code> <code>Any</code> <p>stream options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterator[Optional[Union[MentionNotification, ReplyNotification]]]</code> <p>Iterator[Optional[Union[MentionNotification, ReplyNotification]]]: iterator of notifications. Returns none if pause_after is reached</p> Source code in <code>farcaster/client.py</code> <pre><code>def stream_notifications(\nself, **stream_options: Any\n) -&gt; Iterator[Optional[Union[MentionNotification, ReplyNotification]]]:\n\"\"\"Stream all recent notifications\n    Possible stream options:\n        ``pause_after``: ``Optional[int]`` = ``None``, The number of times to call the API without finding a new item\n        ``skip_existing``: ``bool`` = ``False``, If ``True``, skip items that existed before the stream was created\n        ``max_counter``: ``PositiveInt`` = ``16``, The maximum number of seconds to wait between calls to the API\n    Args:\n        **stream_options: stream options\n    Returns:\n        Iterator[Optional[Union[MentionNotification, ReplyNotification]]]: iterator of notifications. Returns none if pause_after is reached\n    \"\"\"\nreturn stream_generator(\nself._recent_notifications_list,\nattribute_name=\"id\",\nlimit=20,\n**stream_options,\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.stream_users","title":"<code>stream_users(**stream_options)</code>","text":"<p>Stream all recent users.</p> Possible stream options <p><code>pause_after</code>: <code>Optional[int]</code> = <code>None</code>, The number of times to call the API without finding a new item</p> <p><code>skip_existing</code>: <code>bool</code> = <code>False</code>, If <code>True</code>, skip items that existed before the stream was created</p> <p><code>max_counter</code>: <code>PositiveInt</code> = <code>16</code>, The maximum number of seconds to wait between calls to the API</p> <p>Parameters:</p> Name Type Description Default <code>**stream_options</code> <code>Any</code> <p>stream options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterator[Optional[ApiUser]]</code> <p>Iterator[Optional[ApiUser]]: iterator of users. Returns none if pause_after is reached</p> Source code in <code>farcaster/client.py</code> <pre><code>def stream_users(self, **stream_options: Any) -&gt; Iterator[Optional[ApiUser]]:\n\"\"\"Stream all recent users.\n    Possible stream options:\n        ``pause_after``: ``Optional[int]`` = ``None``, The number of times to call the API without finding a new item\n        ``skip_existing``: ``bool`` = ``False``, If ``True``, skip items that existed before the stream was created\n        ``max_counter``: ``PositiveInt`` = ``16``, The maximum number of seconds to wait between calls to the API\n    Args:\n        **stream_options: stream options\n    Returns:\n        Iterator[Optional[ApiUser]]: iterator of users. Returns none if pause_after is reached\n    \"\"\"\nreturn stream_generator(\nself._recent_users_list, attribute_name=\"fid\", limit=20, **stream_options\n)\n</code></pre>"},{"location":"reference/#farcaster.client.Warpcast.unfollow_user","title":"<code>unfollow_user(fid)</code>","text":"<p>Unfollow a user</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>PositiveInt</code> <p>Farcaster ID of the user to unfollow</p> required <p>Returns:</p> Name Type Description <code>StatusContent</code> <code>StatusContent</code> <p>Status of the unfollow</p> Source code in <code>farcaster/client.py</code> <pre><code>def unfollow_user(self, fid: PositiveInt) -&gt; StatusContent:\n\"\"\"Unfollow a user\n    Args:\n        fid (PositiveInt): Farcaster ID of the user to unfollow\n    Returns:\n        StatusContent: Status of the unfollow\n    \"\"\"\nbody = FollowsDeleteRequest(target_fid=fid)\nresponse = self._delete(\n\"follows\",\njson=body.dict(by_alias=True, exclude_none=True),\n)\nreturn StatusResponse(**response).result\n</code></pre>"},{"location":"reference/#farcaster.client.get_wallet","title":"<code>get_wallet(mnemonic=None, private_key=None)</code>","text":"<p>Get a wallet from mnemonic or private key</p> <p>Parameters:</p> Name Type Description Default <code>mnemonic</code> <code>NoneStr</code> <p>mnemonic</p> <code>None</code> <code>private_key</code> <code>NoneStr</code> <p>private key</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[LocalAccount]</code> <p>Optional[LocalAccount]: wallet</p> Source code in <code>farcaster/client.py</code> <pre><code>def get_wallet(\nmnemonic: NoneStr = None, private_key: NoneStr = None\n) -&gt; Optional[LocalAccount]:\n\"\"\"Get a wallet from mnemonic or private key\n    Args:\n        mnemonic (NoneStr): mnemonic\n        private_key (NoneStr): private key\n    Returns:\n        Optional[LocalAccount]: wallet\n    \"\"\"\nAccount.enable_unaudited_hdwallet_features()\nif mnemonic:\naccount: LocalAccount = Account.from_mnemonic(mnemonic)\nreturn account  # pragma: no cover\nelif private_key:\naccount = Account.from_key(private_key)\nreturn account  # pragma: no cover\nreturn None\n</code></pre>"},{"location":"reference/#farcaster.client.now_ms","title":"<code>now_ms()</code>","text":"<p>Get the current time in milliseconds</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>current time in milliseconds</p> Source code in <code>farcaster/client.py</code> <pre><code>def now_ms() -&gt; int:\n\"\"\"Get the current time in milliseconds\n    Returns:\n        int: current time in milliseconds\n    \"\"\"\nreturn int(time.time() * 1000)\n</code></pre>"}]}